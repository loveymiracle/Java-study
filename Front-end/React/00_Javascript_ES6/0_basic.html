<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2>React에서 자주 사용하는 JavaScript ES6 문법 정리</h2>

    <h3>1. Class</h3>
    <div> - ES6에서 JavaScript에서 Calss 표현이 가능하다. </div>
    <div> - Class 선언 및 상속도 가능하다. </div>
    <script>
        // 부모
        class Car{
            constructor(_name){
                // Class에서 사용할 멤버 변수
                this.name = _name;
            }

            // 멤버 메소드
            print(){
                return 'name : ' + this.name;
            }
        }

        class Model extends Car{
            constructor(_name, _model){
                super(_name);
                this.model = _model;
            }

            show(){
                return this.print() + ', model : ' + this.model;
            }
        }

        const bmw = new Model('BMW', 'BMW i5');
        document.write(bmw.show() + '<br>');

        const hyundai = new Model('현대', '소나타');
        document.write(hyundai.show() + '<br>');
    </script>
    <hr><br>

    <h3>2. Arrow Functions</h3>
    <div> - function name(){}에서 ()=>{}로 단축 표현이 가능하다. </div>
    <button onClick="test1()">test1</button>
    <button onClick="test2()">test2</button>
    <button onClick="test3()">test3</button>
    <button onClick="test4('인자')">test4</button>
    <script>
        function test1(){
            alert('test1');
        }

        test2 = function(){
            alert('test2');
        }

        test3 = ()=>{
            alert('test3');
        }

        test4 = (str)=>{
            alert('test4 str : ' + str);
        }
    </script>
    <hr><br>

    <h3>3. Array Methods</h3>
    <div> - map()을 사용하면 배열의 각 항목에 대해 함수를 실행하며 결과로 새 배열을 반환</div>
    <script>
        const myArray = ['apple', 'banana', 'orange'];
        const myList1 = myArray.map((value)=>{return `<li>${value}</li>`});
        const myList2 = myArray.map((value)=>`<li>${value}</li>`);

        myList1.forEach((value, index, array)=>{
            document.write(value);
        });
        document.write('<br>');

        myList2.forEach((value, index, array)=>{
            document.write(value);
        });
    </script>
    <hr><br>

    <h3>4. Destructing Arrays (Array 분해하기)</h3>
    <div> -Destructuring을 사용하면 배열에서 필요한 요소만 쉽게 뽑아서 사용할수 있다.</div>
    <br>
    <script>
        const vehicles1 = ['mustang', 'f-150', 'expedition'];
        // old way
        const car1 = vehicles1[0];
        const truck1 = vehicles1[1];
        const suv1 = vehicles1[2];
        document.write(car1 + ', ' + truck1 + ', ' + suv1 + '<br>');

        const vehicles2 = ['mustang', 'f-150', 'expedition'];
        const [car2, truck2, suv2] = vehicles2;
        const [car3, , suv3] = vehicles2;

        document.write(car2 + ', ' + truck2 + ', ' + suv2 + '<br>');
        document.write(car3 + ', ' + suv3 + '<br>');
    </script>
    <hr><br>

    <h3>5. Spread Operator</h3>
    <div> - JavaScript 스프레드 연산자( ...)를 사용하면 기존 배열이나 개체의 전부 또는 일부를 다른 배열이나 개체에 빠르게 복사 가능하다. </div>
    <div> - 또한 객체에서도 적용 가능한데, 덮어쓰기 형태로 합쳐질수 있다. </div>
    <br>
    <script>
        const numbersOne = [1, 2, 3];
        const numbersTwo = [4, 5, 6];
        // const numbersCombined = numbersOne.concat(numbersTwo);
        const numbersCombined = [...numbersOne, ...numbersTwo];
        document.write('numbersOne : ' + numbersOne + '<br>');
        document.write('numbersTwo : ' + numbersTwo + '<br>');
        document.write('numbersCombined : ' + numbersCombined + '<br><br>');

        // 객체에서 사용할 떄 매우 강력하게 덮어쓰기가 가능하다.
        const myVehicle = {
            brand:'Ford',
            model:'Mustang',
            color:'red'
        }

        const updateMyVehicle = {
            type: 'car',
            year: 2021,
            color: 'yellow'
        }

        // myVehicle -> updateMyVehicle 순으로 적용되므로 최종적으로 updateMyVehicle값이 덮어쓰기 된다.
        const myUpdatedVehicle = {...myVehicle, ...updateMyVehicle};
       
        document.write('myVehicle = ');
        for (let key in myVehicle) {
            document.write(key + ':' + myVehicle[key] + ', ');
        }
        document.write('<br>');
        document.write('updateMyVehicle = ');
        for (let key in updateMyVehicle) {
            document.write(key + ':' + updateMyVehicle[key] + ', ');
        }
        document.write('<br>');
        document.write('myUpdatedVehicle = ');
        for (let key in myUpdatedVehicle) {
            document.write(key + ':' + myUpdatedVehicle[key] + ', ');
        }
        document.write('<br>');
    </script>
    <hr><br>

    <h3>6. Ternary Operator(삼항연산자)</h3>
    <div>- JS에서 삼항연산자는 ES6부터 사용가능했다. </div>
    <div>- Front 계열에서 삼항연산자는 자주 사용되는 문법이라 당연히 필요하다. </div>
    <div>- Syntax: condition ? expression if true : expression if false</div>
    <br>

    <script>
        var name = '홍길동'
        if (name == '홍길동') {
            document.write('<div>홍길동이 맞습니다.</div>');
        } else {
            document.write('<div>홍길동이 아닙니다.</div>');
        }
        // 한줄로 출력하기 위해 사용
        document.write(name == '홍길동' ? '<div>홍길동이 맞습니다.</div>' : '<div>홍길동이 아닙니다.</div>')
        // 백틱(backtick) 문법
        document.write(name == '홍길동' ? `<div>${name}은 홍길동이다.</div>` : `<div>${name}은 홍길동이 아닙니다.</div>`)
    </script>
    <hr><br>

    <h3>7. 프로미스(Promise)</h3>
    <div>- 프로미스는 비동기 작업을 조금 더 편하게 처리 할 수 있도록 ES6 에 도입된 기능 </div>
    <div>- Promise는 성공, 실패 케이스 존재  성공 할 때에는 resolve를 호출, 실패할 때에는 reject 를 호출</div>
    <div>- .then은 성공 케이스로 간주하고 resolve 함수와 연결, .chtch는 실패케이스로 reject과 연결됨  </div>
    <div>- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise</div>
    <br>
    <button onclick="run()">myPromise2</button>
    <br>
    <script>
        // promise 초기화 문법
        const myPromise = new Promise((resolve, reject)=>{
            // 비동기 처리 문장이 들어갈 곳
            // ex) ajax 요청, 파싱 ..
            let a = 1 + 1;
            if(a == 2){
                // 성공 했을 때
                resolve('success');
            } else {
                // 실패 했을 때
                reject('failed');
            }
        });

        // promise 실행
        myPromise.then((msg)=>{
            // 비동기 처리가 되고 비동기로 데이터를 가져와 화면을 업데이트하는 영역
            document.write('This is in the then ' + msg);
        }).catch((msg)=>{
            document.write('This is in the catch ' + msg);
        });

        const myPromise2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('3000ms atfer my message!');
            }, 3000);
        });

        function run(){
            myPromise2.then((msg) => {
                alert(msg);
            });
        }
    </script>
    <hr><br>

    <h3>8. async/await</h3>
    <div>- async/await 문법은 ES8에 해당하는 문법으로서, Promise 를 더욱 쉽게 사용 할 수 있게 도와줌 </div>
    <div>- 함수의 앞부분에 async를 선언하고 그리고 Promise 의 앞부분에 await 을 넣어서 선언</div>
    <div>- 해당 프로미스가 끝날때까지 기다렸다가 다음 작업을 수행 할 수 있습니다.</div>
    <br>
    <button onclick="test1()">기존 Promise</button>
    <button onclick="test2()">async/await</button>
    <button onclick="test3()">동기화 시키지 않았을때</button>

    <script>
        function delay(ms) {
            return new Promise(resolve => {
                setTimeout(() => {
                alert(`${ms} 밀리초가 지났습니다.`);
                resolve();
                }, ms);
            });
        }

        // 기존 promise then() 형식으로 여러 Promise 함수를 동기화 시키는 방법
        function test1(){
            delay(1000).then(()=>{
                // 성공 했을 때 resolve로 호출되는 영역
                return delay(1000);
            }).then(()=>{
                return Promise.resolve('끝');
            }).then((msg)=>{
                alert(msg);
            });
        }

        // 위에 문법을 쉽게 사용하기 위해 async/await 문법으로 대체 가능하다!!
        async function test2(){
            await delay(1000);
            await delay(1000);
            const result = await Promise.resolve('끝');
            alert(result);
        }

        // 동기화 안한 상황
        function test3() {
            delay(1000);
            delay(1000);
            const result = Promise.resolve('끝');
            alert(result);
        }
    </script>

    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>
