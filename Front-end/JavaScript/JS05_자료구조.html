<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>JavaScript - 자료구조</h1>
    <hr>

    <h2>배열(Array)</h2>
    <div> - 데이터의 type을 구분하지 않고 데이터를 담는 자료구조, 크기를 자동으로 관리하는 것이 특징</div>
    <hr><br>
    <script>
        // var array = []; // 가장 기초적인 초기화 문법
        // var array = [1,2,3,4,5];
        var array = ['a', 'b', 'c', 'd',]; // 맨 뒤 괄호 c언어, 자바 둘다 가능한 문법

        for(let i = 0; i < array.length; i++) {
            console.log(array[i]);
        }

        var array1 = [10, 3.5, '홍길동', true, [1,2,3,4,5], document]; // 다양한 type을 담는 배열
        // 전체 데이터 출력
        document.write('전체 데이터 : ' + array1.toString() + '<br>');
        document.write('[0] : ' + array1[0] + '<br>');
        document.write('[1] : ' + array1[1] + '<br>');
        document.write('[2] : ' + array1[2] + '<br>');
        document.write('[3] : ' + array1[3] + '<br>');
        document.write('[4] : ' + array1[4] + '<br>');
        document.write('[5] : ' + array1[5] + '<br>');
        document.write('[6] : ' + array1[6] + '<br>'); // undefined, 데이터가 없음, index를 벗어남
        document.write('[7] : ' + array1[7] + '<br>'); // undefined
        // javascript의 배열은 index가 잘못되어 error가 발생하지 않는 특징이 있다.

        // 배열 순회하는 방법1, 가장 표준적인 반복문이고 ES6 이전에 고전문법! ✭✭✭✭✭
        for(let i = 0; i < array1.length; i++) {
            document.write('['+ i +'] : ' + array1[i] + '<br>');
        }
        document.write('<br>');

        // 배열 순회하는 방법2, ES6 이후 부터 사용 가능한 반복문
        for(let v of array1) {
            document.write(v + '<br>');
        }
        document.write('<br>');
        </script>
        <hr><br>

        <h3>배열의 선언법</h3>
        <div> - 배열의 생성법이 다양하게 존재하며, 크기를 지정하지 않고도 활용 가능</div>

        <script>
            var array2 = new Array();
            var array3 = new Array(3); // 크기를 지정해도 고정은 아니고 초기 배열사이즈를 의미한다.
            var array4 = []; // 추천 ✭✭✭✭✭

            array2[0] = '딸기';
            array2[1] = '바나나';
            array2[2] = '키위';
            document.write('array2 : ' + array2 + '<br>');

            array3[0] = '딸기';
            array3[1] = '바나나';
            array3[2] = '키위';
            array3[3] = '사과';
            array3[4] = '수박';
            array3[5] = '멜론';
            document.write('array3 : ' + array3 + '<br>');

            // array4[0] = '딸기';
            array4[1] = '사과';
            array4[2] = '수박';
            array4[3] = '멜론';
            document.write('array4 : ' + array4 + '<br>');
        </script>
        <hr><br>

        <h3>배열의 선언과 초기화 방법</h3>
        <script>
            var array5 = [10,20,30,40,50,];
            // var array6 = new Array(40,50,60,70,80);
            var array6 = Array(40,50,60,70,80); // new가 생략되어도 잘 된다.
            document.write('array5 : ' + array5 + '<br>');
            document.write('array6 : ' + array6 + '<br>');
        </script>
        <hr><br>

        <h2>배열 주요 메소드(기능)</h2>
        <h3>push() : 배열의 마지막에 index 값 넣기</h3>
        <h3>pop() : 배열의 마지막에 index 값 빼기</h3>
        <script>
            var array1 = [1, 2, 3];
            array1.push(4); // 뒤에서 삽입됨
            array1.push(5);
            document.write('array1 : ' + array1 + '<br>');
            var value = array1.pop();
            document.write('array1 : ' + array1 + '<br>');
            document.write('pop된 값 : ' + value + '<br>');
        </script>
        <hr><br>

        <h3>shift() : 배열의 처음 index에 값 빼기</h3>
        <h3>unshift() : 배열의 처음 index에 값 넣기</h3>
        <script>
            var array1 = ['선택하세요', '서울시', '경기도', '인천시'];
            document.write('기존 array1 : ' + array1 + '<br>');
            var value = array1.shift(); // 가장 앞의 값이 제거됨
            document.write('이후 array1 : ' + array1 + '<br>');
            document.write('제거된 값 : ' + value + '<br>');
            array1.unshift(value); // 가장 앞의 값이 추가됨
            document.write('복원 된 array1 : ' + array1 + '<br>');
        </script>
        <hr><br>

        <h3>indexOf() : 배열에서 요소가 위치한 index를 찾아서 반환, 값이 없으면 -1(음수)</h3>
        <script>
            var array1 = ['사과', '딸기', '바나나', '키위', '파인애플'];
            document.write('바나나 위치 : ' + array1.indexOf('바나나') + '<br>');
            document.write('바나나 텍스트 : ' + array1[array1.indexOf('바나나')] + '<br>');
            document.write('키위 위치 : ' + array1.indexOf('키위') + '<br>');
            document.write('오이 위치(없는 값) : ' + array1.indexOf('오이') + '<br>'); // -1
            document.write('오이 텍스트(없는 값) : ' + array1[array1.indexOf('오이')] + '<br>'); // undefined
        </script>
        <hr><br>

        <h3>concat() : 두개 또는 세계의 배열을 결합</h3>
        <script>
            var array1 = ['사과', '바나나', '키위'];
            var array2 = ['키위', '수박', '파인애플'];
            var array3 = array1.concat(array2);
            var array4 = array2.concat(array1);
            // var array4 = array2.concat(array1).concat(array2); // concat concat 가능!
            var array5 = array1 + array2; // 문자열간 결합! 결과가 배열이 아니다!

            document.write('array1  : ' + array1 + '<br>');
            document.write('array2  : ' + array2 + '<br>');
            document.write('array1 + array2, concat : ' + array3 + '<br>');
            document.write('array2 + array1, concat : ' + array4 + '<br>');
            document.write('array2 + array1, concat : ' + array4.length + '<br>');
            document.write('array2 + array1, concat - typeof : ' + typeof(array4) + '<br>'); // object
            document.write('array1 + array2, + : ' + array5 + '<br>');
            document.write('array1 + array2 - typeof, + : ' + typeof(array5) + '<br>'); // string
        </script>
        <hr><br>

        <h3>join() : 배열을 결합하여 문자열로 반환</h3>
        <script>
            var array1 = ['사과', '바나나', '키위'];
            var str1 = array1.join();
            var str2 = '' + array1; // 같은 결과가 나온다!
            document.write('str1 : ' + str1 + '<br>');
            document.write('str2 : ' + str2 + '<br>');
            document.write('str1 : ' + typeof(str1) + '<br>');
            document.write('str2 : ' + typeof(str2) + '<br>');
        </script>
        <hr><br>

        <h3>reverse() : 배열의 순서를 뒤집는 메소드</h3>
        <script>
            var array1 = [1,2,3,4,5];
            document.write(array1 + '<br>');
            document.write(array1.reverse() + '<br>');
        </script>
        <hr><br>

        <h3>sort() : 배열의 값을 내림차순, 오름차순으로 정렬하는 메소드 ★★★★★</h3>
        <div> - default는 오름차순, 사용자가 내림차순으로 정렬 지정 가능</div>
        <div> - ※ 주의점 : 기본 sort는 문자열 기준으로 정렬됨, 숫자는 제대로 정렬되지 않음</div>

        <script>
            var arr1 = [10, 492, 20, 3212, 12, 322, 4, 262, 800];
            var arr2 = ['홍길동', '박길동', '김동길', '차길동', '김길동', '홍동길', '최길동', '팍길동', '이길동'];

            // 숫자 오름차순 정렬 함수
            var sortNumACS = function(x, y){
                return x - y; // 크면 양수, 작으면 음수, 같으면 0
            }
            // 숫자 내림차순 정렬 함수
            var sortNumDESC = function(x, y){
                return y - x; // 크면 양수, 작으면 음수, 같으면 0
            }

            // 문자 오름차순 (공부용, 2중정렬 할 때 참고)
            var sortStrASC = function(x, y) {
                // if(x > y) { // 문자열간 대소비교가 정렬순서가 됨.
                //     return 1;
                // } else if (x < y) {
                //     return -1;
                // } else {
                //     return 0;
                // }
                return x.localeCompare(y);
            }

            // 문자 오름차순 (공부용, 2중정렬 할 때 참고)
            var sortStrDESC = function(x, y) {
                // if(x < y) { // 문자열간 대소비교가 정렬순서가 됨.
                //     return 1;
                // } else if (x > y) {
                //     return -1;
                // } else {
                //     return 0;
                // }
                return y.localeCompare(x);
            }
            
            // 숫자 정렬 출력 -> 그냥하면 문제 생김으로 주의!! ※※ 문자열로 저장하는 메커니즘 때문..
            document.write('원래 차순 : ' + arr1 + '<br>');
            document.write('기본 정렬(오름) : ' + arr1.sort() + '<br>');
            document.write('오름 차순 : ' + arr1.sort(sortNumACS) + '<br>');
            document.write('내림 차순 : ' + arr1.sort(sortNumACS).reverse() + '<br>');
            document.write('내림 차순2 : ' + arr1.sort(sortNumDESC) + '<br>');
            document.write('오름 차순(익명함수)' + arr1.sort(function (x,y){return x - y;})+ '<br>');
            document.write('오름 차순(람다)' + arr1.sort((x,y)=> {return x - y;})+ '<br>'); // 람다식 표현
            document.write('<br>');

            // 문자 정렬 출력
            document.write('원래 차순 : ' + arr2 + '<br>');
            document.write('기본 정렬(오름) : ' + arr2.sort() + '<br>');
            document.write('내림 차순 : ' + arr2.sort().reverse() + '<br>');
            document.write('오름 차순(수동)) : ' + arr2.sort(sortStrASC) + '<br>');
            document.write('내림 차순(수동)) : ' + arr2.sort(sortStrDESC) + '<br>');
            document.write('오름 차순(람다)' + arr2.sort((x,y) => x.localeCompare(y)) + '<br>'); // 람다식 표현

        </script>
        <hr><br>

        <h3>slice() : 배열의 요소를 잘라내는 메소드 원본배열 복사해서 사용, 원본손상 없음!</h3>
        <h3>splice() : 배열의 요소를 잘라내는 메소드, 원본에 적용된다. (delete, remove 대체하는 기능)</h3>
        <br>
        <script>
            // slice 
            var array1 = ['사과', '딸기', '바나나', '키위', '파인애플'];
            var array2 = array1.slice(2, 4); // 시작점, 끝점(index 기준)
            document.write('array1(원본) : ' + array1 + '<br>');
            document.write('array2(slice) : ' + array2 + '<br>');

            // splice : ui상에서 제거된 html element 다른쪽으로 추가하려고 할 때
            var array1 = ['사과', '딸기', '바나나', '키위', '파인애플'];
            document.write('array1(원본) : ' + array1 + '<br>');
            var array2 = array1.splice(2, 4); // 시작점, 삭제할 데이터 갯수
            document.write('array1(splice) : ' + array1 + '<br>');
            document.write('array2(splice) : ' + array2 + '<br>');

            // splice - 응용 특정 index 지우기
            var array1 = ['사과', '딸기', '바나나', '키위', '파인애플'];
            document.write('array1(원본) : ' + array1 + '<br>');
            // 2번째 인덱스만 삭제할 때
            array1.splice(2, 1); // 시작점, 삭제할 데이터 갯수
            document.write('array1(splice) : ' + array1 + '<br>');

            // splice - 응용 특정 index부터 모두 지우기
            var array1 = ['사과', '딸기', '바나나', '키위', '파인애플'];
            document.write('2번째부터 모든 인덱스 삭제 법<br>');
            document.write('array1(원본) : ' + array1 + '<br>');
            // 2번째 인덱스만 삭제할 때
            array1.splice(2); // 시작점만 두고 끝점까지 모두 삭제
            document.write('array1(splice) : ' + array1 + '<br>');

            // splice - 데이터를 지우고 특정 데이터로 메꾸기1
            var array1 = ['사과', '딸기', '바나나', '키위', '파인애플'];
            document.write('데이터를 지우고 특정 데이터로 메꾸기1<br>');
            document.write('array1(원본) : ' + array1 + '<br>');
            // 2번째 인덱스만 삭제할 때
            array1.splice(2, 2, '배', '토마토', '오이'); // 시작점, 삭제할 데이터 갯수, 메꿀 데이터(나열로..)
            // array1.splice(2, 2, ['배', '토마토', '오이']); // 잘못된 문법, 배열이 1개 데이터 영역으로 삽입됨
            document.write('array1(splice) : ' + array1 + '<br>');

            // splice - 데이터를 지우고 특정 데이터로 메꾸기2
            var array1 = ['사과', '딸기', '바나나', '키위', '파인애플'];
            document.write('데이터를 지우고 특정 데이터로 메꾸기2<br>');
            document.write('array1(원본) : ' + array1 + '<br>');
            // 2번째 인덱스만 삭제할 때
            array1.splice(2, 2, '배', '토마토', '오이'); // 시작점, 삭제할 데이터 갯수, 메꿀 데이터(나열로..)
            // array1.splice(2, 2, ['배', '토마토', '오이']); // 잘못된 문법, 배열이 1개 데이터 영역으로 삽입됨
            document.write('array1(splice) : ' + array1 + '<br>');
        </script>
        <hr><br>

        <h3>toString() : 배열을 문자열로 반환</h3>
        <script>
            var arr1 = ['사과', '키위', '토마토', '블루베리', '파일애플'];
            document.write('원본 : ' + arr1 + '<br>');
            document.write('원본 : ' + arr1.toString() + '<br>');
        </script>
        <hr><br>

        <h3>flat() : 다차원 배열을 1차원으로 변환하는 메소드</h3>
        <script>
            var arr1 = [[1,2,3],[4,5,6],[7,8,9]];
            document.write('원본 : ' + arr1 + '<br>');
            document.write('원본 : ' + arr1[0] + '<br>');
            document.write('원본 : ' + arr1.flat() + '<br>');
            document.write('원본 : ' + arr1.flat()[0] + '<br>');
        </script>
        <hr><br>

        <h3>find() : 조건을 찾아서 한개의 값만 반환하는 함수 (ES6)</h3>
        <script>
            const ages = [3, 10, 12, 14, 16, 18, 20];
            function checkAge(age){
                if(age > 15) {
                    return age;
                }
            }
            var value = ages.find(checkAge);
            document.write('ages : ' + ages + '<br>');
            document.write('value : ' + value + '<br>');
            document.write('value : ' + typeof(value) + '<br>');
            // 없는 경우는 undefined
            var value = ages.find((age) => {if(age == 15) return age;});
            document.write('value : ' + value + '<br>');
        </script>

        <h3>filter() : 조건을 찾아서 배열로 반환하는 함수  (ES6)</h3>
        <script>
            const ages2 = [3, 10, 12, 14, 16, 18, 20];
            function checkAge(age) {
                if (age > 15) {
                    return age;
                }
            }
            var arr1 = ages2.filter(checkAge);
            var arr2 = ages2.filter((age) => {
                if (age > 15){
                    return age;
                }
            });
            document.write('ages : ' + ages + '<br>');
            document.write('arr1 : ' + arr1 + '<br>');
            document.write('arr2 : ' + arr1 + '<br>');
        </script>
        <hr><br><br>

        <h3>reduce() : 일부 조건만 찾아서 반환하는 함수  (ES6)</h3>
        <script>
            const ages3 = [3, 10, 12, 14, 16, 18, 20];

            // 15살 이상만 sum 구하기
            function reduceFunc(acc, cur, index, array) { // acc: 계산 값, cur : 현재값, index, array
                if(cur > 15) {
                    return acc + cur;
                }
                return acc;
            }

            var sumValue = ages3.reduce(reduceFunc);
            document.write('sum : ' + sumValue + '<br>');
            var sumValue = ages3.reduce((acc, cur) => cur > 15 ? acc + cur : acc);
            document.write('sum : ' + sumValue + '<br>');
        </script>

        <h2>Set(ES6)</h2>
        <div> - type과 상관 없이 중복없이 데이터 저장하는 자료구조</div>
        <hr><br>

        <script>
            var set1 = new Set();
            set1.add('a');
            set1.add('a');
            set1.add('b');
            set1.add('b');
            set1.add('c');
            set1.add('c');
            set1.add('c');
            document.write('크기 : ' + set1.size + '<br>');
            document.write('전체 데이터 : ');
            // 순회하는 방법
            // set1.forEach(function(v){
            //     document.write(v + ', ');
            // })
            set1.forEach((v) => document.write(v + ', '));
            document.write('<br>');
            // 순회하는 방법2
            document.write('전체 데이터 : ');
            for(var v of set1) {
                document.write(v + ',');
            }
            document.write('<br>')

            // 초기화 방법2
            var set2 = new Set([1, 2, 3, 1, 2, 3,]);
            document.write('크기 : ' + set2.size + '<br>');
            document.write('전체 데이터 : ');
            set2.forEach((v) => document.write(v + ', '));
            document.write('<br>');

            // Set -> Array로 변환방법
            var array = Array.from(set2);
            document.write('array : ' + array);
            var array2 = [... set2];
            document.write('<br>');
            document.write('array2 : ' + array2);
            document.write('<br>');

            // iterator 돌리는 방법
            var iterator = set2.values(); // IterableIterator<number>
            var i = 0;
            while(i < set2.size){
                document.write(iterator.next().value + ',');
                i++;
            }
            document.write('<br>');
        </script>
        <hr><br>

        <h2>Map(ES6)</h2>
        <div> - Key-Value를 통해 데이터를 관리하는 자료구조, Object 보다 빠르다는 장점이 존재 (Hashcode 활용)</div>
        <hr><br>
        <script>
            var map1 = new Map();
            map1.set('name', '홍길동');
            map1.set('age',25);
            map1.set('hobby', ['축구', '야구']);
            document.write('크기 : ' + map1.size + '<br>');
            document.write('전체 데이터 : ' + map1 + '<br>');
            console.log(map1); 
            document.write('전체 데이터 : ');
            // 순회하는 방법
            map1.forEach((key, value) => document.write(key + ' : ' + value + '<br>'));
            document.write('<br>');
            document.write('이름이 있는지? ' + map1.has('name') + '<br>'); // true
            document.write('주소가 있는지? ' + map1.has('address') + '<br>'); // false
            document.write('이름값 : ' + map1.get('name') + '<br>'); // 홍길동
            document.write('주소값 : ' + map1.get('address') + '<br>'); // undefined
            document.write('<br>');
            map1.delete('age');

            for(var entry of map1.entries()){
                document.write(entry + '<br>');
            }

        </script>




        <br><br><br><br><br><br><br><br><br><br>
        <br><br><br><br><br><br><br><br><br><br>


    
</body>
</html>
